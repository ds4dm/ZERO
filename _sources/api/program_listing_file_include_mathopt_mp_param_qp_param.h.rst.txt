
.. _program_listing_file_include_mathopt_mp_param_qp_param.h:

Program Listing for File qp_param.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_mathopt_mp_param_qp_param.h>` (``include/mathopt/mp_param/qp_param.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   /* #############################################
    *             This file is part of
    *                    ZERO
    *
    *             Copyright (c) 2020
    *     Released under the Creative Commons
    *        Zero v1.0 Universal License
    *
    *              Find out more at
    *        https://github.com/ds4dm/ZERO
    * #############################################*/
   
   
   #pragma once
   #include "zero.h"
   #include <armadillo>
   #include <gurobi_c++.h>
   #include <iostream>
   #include <memory>
   #include <set>
   #include <string>
   
   
   
   namespace MathOpt {
     std::ostream &operator<<(std::ostream &os, const QP_Param &Q);
     class QP_Param : public MP_Param {
     private:
        // Gurobi environment and model
        GRBModel Model;
        bool     MadeyQy;
   
        int makeyQy();
   
     public: // Constructors
        explicit QP_Param(GRBEnv *env = nullptr) : MP_Param(env), MadeyQy{false}, Model{(*env)} {
           this->size();
        }
   
        QP_Param(arma::sp_mat Q,
                    arma::sp_mat C,
                    arma::sp_mat A,
                    arma::sp_mat B,
                    arma::vec    c,
                    arma::vec    b,
                    GRBEnv *     env = nullptr)
             : MP_Param(env), MadeyQy{false}, Model{(*env)} {
           this->MadeyQy = false;
           this->set(Q, C, A, B, c, b);
           this->size();
           this->forceDataCheck();
        };
   
        QP_Param(const QP_Param &Qu) : MP_Param(Qu), Model{Qu.Model}, MadeyQy{Qu.MadeyQy} {
           this->size();
        };
   
        void forceDataCheck() const;
        // Override setters
        QP_Param &set(const arma::sp_mat &Q,
                           const arma::sp_mat &C,
                           const arma::sp_mat &A,
                           const arma::sp_mat &B,
                           const arma::vec &   c,
                           const arma::vec &   b) final; // Copy data into this
        QP_Param &set(arma::sp_mat &&Q,
                           arma::sp_mat &&C,
                           arma::sp_mat &&A,
                           arma::sp_mat &&B,
                           arma::vec &&   c,
                           arma::vec &&   b) final; // Move data into this
        QP_Param &set(const QP_Objective &obj, const QP_Constraints &cons) final;
   
        QP_Param &set(QP_Objective &&obj, QP_Constraints &&cons) final;
   
        bool operator==(const QP_Param &Q2) const;
   
        // Other methods
        unsigned int KKT(arma::sp_mat &M, arma::sp_mat &N, arma::vec &q) const override;
   
        std::unique_ptr<GRBModel> solveFixed(arma::vec x, bool solve) override;
   
        double computeObjective(const arma::vec &y,
                                        const arma::vec &x,
                                        bool             checkFeas = true,
                                        double           tol       = 1e-6) const override;
   
        inline bool isPlayable(const QP_Param &P) const
        {
           bool b1, b2, b3;
           b1 = (this->Nx + this->Ny) == (P.getNx() + P.getNy());
           b2 = this->Nx >= P.getNy();
           b3 = this->Ny <= P.getNx();
           return b1 && b2 && b3;
        }
   
        QP_Param &addDummy(unsigned int pars, unsigned int vars = 0, int position = -1) override;
   
        void save(const std::string &filename, bool append) const override;
   
        long int  load(const std::string &filename, long int pos = 0) override;
        double    computeObjectiveWithoutOthers(const arma::vec &y) const;
        arma::vec getConstraintViolations(const arma::vec x, const arma::vec y, double tol);
     };
   } // namespace MathOpt
