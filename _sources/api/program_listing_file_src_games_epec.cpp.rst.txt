
.. _program_listing_file_src_games_epec.cpp:

Program Listing for File epec.cpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_games_epec.cpp>` (``src/games/epec.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   /* #############################################
    *             This file is part of
    *                    ZERO
    *
    *             Copyright (c) 2020
    *     Released under the Creative Commons
    *        Zero v1.0 Universal License
    *
    *              Find out more at
    *        https://github.com/ds4dm/ZERO
    * #############################################*/
   
   #include "games/epec.h"
   #include "games/algorithms/EPEC/epec_polybase.h"
   #include "zero.h"
   #include <armadillo>
   #include <boost/log/trivial.hpp>
   #include <iostream>
   #include <memory>
   
   void Game::EPEC::preFinalize()
   {}
   
   void Game::EPEC::postFinalize()
   {}
   
   void Game::EPEC::finalize()
   {
     if (this->Finalized)
        std::cerr << "Warning in Game::EPEC::finalize: Model already Finalized\n";
   
     this->NumPlayers = static_cast<int>(this->PlayersLowerLevels.size());
     ;
     this->preFinalize();
   
     this->ConvexHullVariables = std::vector<unsigned int>(this->NumPlayers, 0);
     this->Stats.AlgorithmData.FeasiblePolyhedra.set(std::vector<unsigned int>(this->NumPlayers, 0));
     this->computeLeaderLocations(this->numMCVariables);
     // Initialize leader objective and PlayersQP
     this->LeaderObjective           = std::vector<std::shared_ptr<MathOpt::QP_Objective>>(NumPlayers);
     this->LeaderObjectiveConvexHull = std::vector<std::shared_ptr<MathOpt::QP_Objective>>(NumPlayers);
     this->PlayersQP                 = std::vector<std::shared_ptr<MathOpt::QP_Param>>(NumPlayers);
     this->PlayersLCP                = std::vector<std::shared_ptr<MathOpt::LCP>>(NumPlayers);
     this->SizesWithoutHull          = std::vector<unsigned int>(NumPlayers, 0);
   
     for (unsigned int i = 0; i < this->NumPlayers; i++) {
        this->addDummyLead(i);
        this->LeaderObjective.at(i)           = std::make_shared<MathOpt::QP_Objective>();
        this->LeaderObjectiveConvexHull.at(i) = std::make_shared<MathOpt::QP_Objective>();
        this->makeObjectivePlayer(i, *this->LeaderObjective.at(i).get());
        // this->PlayersLCP.at(i) =std::shared_ptr<MathOpt::PolyLCP>(new
        // PolyLCP(this->Env,*this->PlayersLowerLevels.at(i).get()));
        this->SizesWithoutHull.at(i) = *this->LocEnds.at(i);
     }
   
     this->Finalized = true;
   
     this->postFinalize();
   }
   
   void Game::EPEC::addDummyLead(
        const unsigned int i 
   ) {
     const unsigned int nEPECvars        = this->NumVariables;
     const unsigned int nThisCountryvars = *this->LocEnds.at(i);
     // this->Locations.at(i).at(Models::LeaderVars::End);
   
     if (nEPECvars < nThisCountryvars)
        throw ZEROException(ZEROErrorCode::Assertion,
                                   "Mismatch between variable counts " + std::to_string(nEPECvars) + " and " +
                                        std::to_string(nThisCountryvars));
   
     this->PlayersLowerLevels.at(i).get()->addDummy(nEPECvars - nThisCountryvars);
   }
   
   void Game::EPEC::computeLeaderLocations(const unsigned int addSpaceForMC) {
     this->LeaderLocations       = std::vector<unsigned int>(this->NumPlayers);
     this->LeaderLocations.at(0) = 0;
     for (unsigned int i = 1; i < this->NumPlayers; i++) {
        this->LeaderLocations.at(i) = this->LeaderLocations.at(i - 1) + *this->LocEnds.at(i - 1);
     }
     this->NumVariables = this->LeaderLocations.back() + *this->LocEnds.back() + addSpaceForMC;
   }
   
   void Game::EPEC::getXMinusI(const arma::vec &x, const unsigned int &i, arma::vec &solOther) const {
     const unsigned int nEPECvars            = this->NumVariables;
     const unsigned int nThisCountryvars     = *this->LocEnds.at(i);
     const unsigned int nThisCountryHullVars = this->ConvexHullVariables.at(i);
     const unsigned int nConvexHullVars      = static_cast<const unsigned int>(
         std::accumulate(this->ConvexHullVariables.rbegin(), this->ConvexHullVariables.rend(), 0));
   
     solOther.zeros(nEPECvars -        // All variables in EPEC
                         nThisCountryvars - // Subtracting this country's variables,
                         // since we only want others'
                         nConvexHullVars +      // We don't want any convex hull variables
                         nThisCountryHullVars); // We subtract the hull variables
                                                        // associated to the ith player
                                                        // convex hull vars, since we double subtracted
   
     for (unsigned int j = 0, count = 0, current = 0; j < this->NumPlayers; ++j) {
        if (i != j) {
           current = *this->LocEnds.at(j) - this->ConvexHullVariables.at(j);
           solOther.subvec(count, count + current - 1) =
                x.subvec(this->LeaderLocations.at(j), this->LeaderLocations.at(j) + current - 1);
           count += current;
        }
     }
     // We need to keep track of MC_vars also for this country
     for (unsigned int j = 0; j < this->numMCVariables; j++)
        solOther.at(solOther.n_rows - this->numMCVariables + j) =
             x.at(this->NumVariables - this->numMCVariables + j);
   }
   
   void Game::EPEC::getXofI(const arma::vec &   x,
                                    const unsigned int &i,
                                    arma::vec &         solI,
                                    bool                hull) const {
     const unsigned int nThisCountryvars     = *this->LocEnds.at(i);
     const unsigned int nThisCountryHullVars = this->ConvexHullVariables.at(i);
   
     unsigned int vars, current = 0;
     if (hull) {
        vars    = nThisCountryvars;
        current = *this->LocEnds.at(i);
     } else {
        vars    = nThisCountryvars - nThisCountryHullVars;
        current = *this->LocEnds.at(i) - this->ConvexHullVariables.at(i);
     }
     solI.zeros(vars);
     solI.subvec(0, vars - 1) =
           x.subvec(this->LeaderLocations.at(i), this->LeaderLocations.at(i) + current - 1);
   }
   
   void Game::EPEC::getXWithoutHull(const arma::vec &x, arma::vec &xWithoutHull) const {
     const unsigned int nEPECvars       = this->NumVariables;
     const unsigned int nConvexHullVars = static_cast<const unsigned int>(
           std::accumulate(this->ConvexHullVariables.rbegin(), this->ConvexHullVariables.rend(), 0));
   
     xWithoutHull.zeros(nEPECvars -       // All variables in EPEC
                               nConvexHullVars); // We subtract the hull variables
                                                       // associated to the convex hull
                                                       // convex hull vars
   
     for (unsigned int j = 0, count = 0, current; j < this->NumPlayers; ++j) {
        current = *this->LocEnds.at(j) - this->ConvexHullVariables.at(j);
        xWithoutHull.subvec(count, count + current - 1) =
             x.subvec(this->LeaderLocations.at(j), this->LeaderLocations.at(j) + current - 1);
        count += current;
     }
   }
   
   std::unique_ptr<GRBModel> Game::EPEC::respond(const unsigned int i, const arma::vec &x) const {
     if (!this->Finalized)
        throw ZEROException(ZEROErrorCode::Assertion, "The model was not Finalized");
   
     if (i >= this->NumPlayers)
        throw ZEROException(ZEROErrorCode::OutOfRange, "Country number is invalid");
   
     arma::vec solOther;
     this->getXMinusI(x, i, solOther);
     if (this->LeaderObjective.at(i)->Q.n_nonzero > 0)
        return this->PlayersLCP.at(i).get()->MPECasMIQP(this->LeaderObjective.at(i)->Q,
                                                                        this->LeaderObjective.at(i)->C,
                                                                        this->LeaderObjective.at(i)->c,
                                                                        solOther,
                                                                        true);
     else
        return this->PlayersLCP.at(i).get()->MPECasMILP(
             this->LeaderObjective.at(i)->C, this->LeaderObjective.at(i)->c, solOther, true);
   }
   
   double
   Game::EPEC::respondSol(arma::vec &      sol,    
                                 unsigned int     player, 
                                 const arma::vec &x, 
                                 const arma::vec &prevDev
                                 ) const {
     auto model = this->respond(player, x);
     LOG_S(1) << "Game::EPEC::respondSol: Writing dat/RespondSol" + std::to_string(player) +
                           ".lp to disk";
     model->write("dat/RespondSol" + std::to_string(player) + ".lp");
     const int status = model->get(GRB_IntAttr_Status);
     if (status == GRB_UNBOUNDED || status == GRB_OPTIMAL) {
        unsigned int Nx = this->PlayersLCP.at(player)->getNumCols();
        sol.zeros(Nx);
        for (unsigned int i = 0; i < Nx; ++i)
           sol.at(i) = model->getVarByName("x_" + std::to_string(i)).get(GRB_DoubleAttr_X);
   
        if (status == GRB_UNBOUNDED) {
           LOG_S(WARNING) << "Game::EPEC::respondSol: deviation is "
                                   "unbounded.";
           GRBLinExpr obj = 0;
           model->setObjective(obj);
           model->optimize();
           if (!prevDev.empty()) {
             LOG_S(1) << "Generating an improvement basing on the extreme ray.";
             // Fetch objective function coefficients
             GRBQuadExpr QuadObj = model->getObjective();
             arma::vec   objcoeff;
             for (unsigned int i = 0; i < QuadObj.size(); ++i)
                objcoeff.at(i) = QuadObj.getCoeff(i);
   
             // Create objective function objects
             arma::vec objvalue = prevDev * objcoeff;
             arma::vec newobjvalue{0};
             bool      improved{false};
   
             // improve following the unbounded ray
             while (!improved) {
                for (unsigned int i = 0; i < Nx; ++i)
                   sol.at(i) = sol.at(i) +
                                   model->getVarByName("x_" + std::to_string(i)).get(GRB_DoubleAttr_UnbdRay);
                newobjvalue = sol * objcoeff;
                if (newobjvalue.at(0) < objvalue.at(0))
                   improved = true;
             }
             return newobjvalue.at(0);
   
           } else {
             return model->get(GRB_DoubleAttr_ObjVal);
           }
        }
        if (status == GRB_OPTIMAL) {
           return model->get(GRB_DoubleAttr_ObjVal);
        }
     } else {
        return GRB_INFINITY;
     }
     return GRB_INFINITY;
   }
   
   const void Game::EPEC::makePlayerQP(const unsigned int i)
   {
     // LOG_S(INFO) << "Starting Convex hull computation of the country
     // "
     // << this->AllLeadPars[i].name << '\n';
     if (!this->Finalized)
        throw ZEROException(ZEROErrorCode::Assertion, "The model was not Finalized");
     if (i >= this->NumPlayers)
        throw ZEROException(ZEROErrorCode::OutOfRange, "The player id is out of range");
     // if (!this->PlayersQP.at(i).get())
     {
        this->PlayersQP.at(i)     = std::make_shared<MathOpt::QP_Param>(this->Env);
        const auto &origLeadObjec = *this->LeaderObjective.at(i).get();
   
        this->LeaderObjectiveConvexHull.at(i).reset(
             new MathOpt::QP_Objective{origLeadObjec.Q, origLeadObjec.C, origLeadObjec.c});
        this->PlayersLCP.at(i)->makeQP(*this->LeaderObjectiveConvexHull.at(i).get(),
                                                 *this->PlayersQP.at(i).get());
     }
   }
   
   void Game::EPEC::makePlayersQPs()
   {
     for (unsigned int i = 0; i < this->NumPlayers; ++i) {
        this->Game::EPEC::makePlayerQP(i);
     }
     for (unsigned int i = 0; i < this->NumPlayers; ++i) {
        // LeadLocs &Loc = this->Locations.at(i);
        // Adjusting "stuff" because we now have new convHull variables
        unsigned long int originalSizeWithoutHull = this->LeaderObjective.at(i)->Q.n_rows;
        unsigned long int convHullVarCount =
             this->LeaderObjectiveConvexHull.at(i)->Q.n_rows - originalSizeWithoutHull;
   
        LOG_S(1) << "Game::EPEC::makePlayerQP: Added " << convHullVarCount
                    << " convex hull variables to QP #" << i;
   
        // Location details
        this->ConvexHullVariables.at(i) = convHullVarCount;
        // All other players' QP
        if (this->NumPlayers > 1) {
           for (unsigned int j = 0; j < this->NumPlayers; j++) {
             if (i != j) {
                this->PlayersQP.at(j)->addDummy(
                     convHullVarCount,
                     0,
                     this->PlayersQP.at(j)->getNx() -
                           this->numMCVariables); // The position to add parameters is
                                                         // towards the end of all parameters,
                                                         // giving space only for the
                                                         // numMCVariables number of market
                                                         // clearing variables
             }
           }
        }
     }
     this->updateLocations();
     this->computeLeaderLocations(this->numMCVariables);
   }
   
   void Game::EPEC::makeTheLCP() {
     if (this->PlayersQP.front() == nullptr) {
        LOG_S(ERROR) << "Exception in Game::EPEC::makeTheLCP : "
                             "no country QP has been "
                             "made."
                         << '\n';
        throw ZEROException(ZEROErrorCode::Assertion, "No country QP has been made");
     }
     // Preliminary set up to get the LCP ready
     unsigned long int Nvar = this->PlayersQP.front()->getNx() + this->PlayersQP.front()->getNy();
     arma::sp_mat      MC(0, Nvar), dumA(0, Nvar);
     arma::vec         MCRHS, dumb;
     MCRHS.zeros(0);
     dumb.zeros(0);
     this->makeMCConstraints(MC, MCRHS);
     LOG_S(1) << "Game::EPEC::makeTheLCP(): Market Clearing "
                     "constraints are ready";
     std::vector<std::shared_ptr<MathOpt::MP_Param>> MPCasted;
     for (auto &item : this->PlayersQP) {
        auto m = std::dynamic_pointer_cast<MathOpt::MP_Param>(item);
        MPCasted.push_back(m);
     }
     this->TheNashGame = std::unique_ptr<Game::NashGame>(
           new Game::NashGame(this->Env, MPCasted, MC, MCRHS, 0, dumA, dumb));
     LOG_S(1) << "Game::EPEC::makeTheLCP(): NashGame is ready";
     this->TheLCP = std::unique_ptr<MathOpt::LCP>(new MathOpt::LCP(this->Env, *TheNashGame));
     LOG_S(1) << "Game::EPEC::makeTheLCP(): LCP is ready";
   
   
     LOG_S(1) << *TheNashGame;
   }
   
   bool Game::EPEC::computeNashEq(bool   pureNE,         
                                            double localTimeLimit, 
                                            bool   check 
   ) {
     // Make the Nash Game between countries
     this->NashEquilibrium = false;
     LOG_S(1) << " Game::EPEC::computeNashEq: Making the Master LCP";
     this->makeTheLCP();
     LOG_S(1) << " Game::EPEC::computeNashEq: Made the Master LCP";
   
   
     if (check || pureNE) {
        if (this->Stats.AlgorithmData.LCPSolver.get() == Data::LCP::Algorithms::PATH)
           LOG_S(1) << " Game::EPEC::computeNashEq: Cannot use PATH fallback. Using MIP";
        /*
         * In these cases, we can only use a MIP solver to get multiple solutions or PNEs
         */
        this->LCPModel = this->TheLCP->LCPasMIP(false);
        if (localTimeLimit > 0) {
           this->LCPModel->set(GRB_DoubleParam_TimeLimit, localTimeLimit);
        }
   
        if (pureNE) {
           LOG_S(INFO) << " Game::EPEC::computeNashEq: (PureNashEquilibrium flag is "
                               "true) Searching for a pure NE.";
           if (this->Stats.AlgorithmData.Algorithm.get() != Data::EPEC::Algorithms::OuterApproximation)
             static_cast<Algorithms::EPEC::PolyBase *>(this->Algorithm.get())->makeThePureLCP();
        }
   
        this->LCPModel->set(GRB_IntParam_OutputFlag, 1);
        if (check)
           this->LCPModel->set(GRB_IntParam_SolutionLimit, GRB_MAXINT);
   
   
        this->LCPModel->setObjective(GRBLinExpr{0}, GRB_MINIMIZE);
        this->LCPModel->optimize();
        this->LCPModel->write("dat/TheLCPTest.lp");
   
   
        // Search just for a feasible point
        try { // Try finding a Nash equilibrium for the approximation
           this->NashEquilibrium =
                this->TheLCP->extractSols(this->LCPModel.get(), SolutionZ, SolutionX, true);
        } catch (GRBException &e) {
           throw ZEROException(e);
        }
        if (this->NashEquilibrium) { // If a Nash equilibrium is found, then update
                                               // appropriately
           this->LCPModel->write("dat/TheLCPTest.sol");
           if (check) {
             int scount = this->LCPModel->get(GRB_IntAttr_SolCount);
             LOG_S(INFO) << "Game::EPEC::computeNashEq: number of equilibria is " << scount;
             for (int k = 0, stop = 0; k < scount && stop == 0; ++k) {
                this->LCPModel->set(GRB_IntParam_SolutionNumber, k);
                this->NashEquilibrium = this->TheLCP->extractSols(
                     this->LCPModel.get(), this->SolutionZ, this->SolutionX, true);
                if (this->Algorithm->isSolved()) {
                   LOG_S(INFO) << "Game::EPEC::computeNashEq: an "
                                       "Equilibrium has been found";
                   stop = 1;
                }
             }
           } else {
             this->NashEquilibrium = true;
             // this->SolutionX.save("dat/X.dat", arma::file_type::arma_ascii);
             // this->SolutionZ.save("dat/Z.dat", arma::file_type::arma_ascii);
             LOG_S(INFO) << "Game::EPEC::computeNashEq: an Equilibrium has been found";
           }
   
        } else { // If not, then update accordingly
           LOG_S(INFO) << "Game::EPEC::computeNashEq: no equilibrium has been found.";
           int status = this->LCPModel->get(GRB_IntAttr_Status);
           if (status == GRB_TIME_LIMIT)
             this->Stats.Status = ZEROStatus::TimeLimit;
           else
             this->Stats.Status = ZEROStatus::NashEqNotFound;
        }
        return this->NashEquilibrium;
     } else {
   
        auto solver = this->Stats.AlgorithmData.LCPSolver.get();
   
        if (solver == Data::LCP::Algorithms::PATH && this->TheLCP->hasCommonConstraints()) {
           LOG_S(1)
                << " Game::EPEC::computeNashEq: Cannot use PATH fallback (Common constraints). Using MIP";
           solver = Data::LCP::Algorithms::MIP;
        }
   
        switch (this->TheLCP->solve(solver, this->SolutionX, this->SolutionZ, localTimeLimit)) {
        case ZEROStatus::NashEqFound: {
           this->NashEquilibrium = true;
           LOG_S(INFO) << "Game::EPEC::computeNashEq: an Equilibrium has been found";
        } break;
        case ZEROStatus::TimeLimit: {
           this->Stats.Status = ZEROStatus::TimeLimit;
           LOG_S(INFO) << "Game::EPEC::computeNashEq: Time limit attained";
        } break;
        default:
           this->Stats.Status = ZEROStatus::NashEqNotFound;
           LOG_S(INFO) << "Game::EPEC::computeNashEq: no equilibrium has been found.";
        }
        return this->NashEquilibrium;
     }
   
     return false;
   }
   
   bool Game::EPEC::warmstart(const arma::vec x) { //@todo complete implementation
   
     if (x.size() < this->getNumVar())
        throw ZEROException(ZEROErrorCode::OutOfRange,
                                   "The number of variables does not fit the instance");
   
     if (!this->Finalized) {
        throw ZEROException(ZEROErrorCode::Assertion, "The EPEC was not Finalized");
     }
     if (this->PlayersQP.front() == nullptr) {
        LOG_S(WARNING) << "Game::EPEC::warmstart: Generating QP as of warmstart.";
     }
   
     this->SolutionX                  = x;
     std::vector<arma::vec> devns     = std::vector<arma::vec>(this->NumPlayers);
     std::vector<arma::vec> prevDevns = std::vector<arma::vec>(this->NumPlayers);
     this->makePlayersQPs();
   
     arma::vec devn;
   
     if (this->Algorithm->isSolved())
        LOG_S(WARNING) << "Game::EPEC::warmstart: "
                                "The loaded solution is optimal.";
     else
        LOG_S(WARNING) << "Game::EPEC::warmstart: "
                                "The loaded solution is NOT optimal. Trying to repair.";
     return true;
   }
   bool Game::EPEC::isPureStrategy(double tol) const {
     return this->Algorithm->isPureStrategy(tol);
   }
   bool Game::EPEC::isSolved(double tol) const {
     return this->Algorithm->isSolved(tol);
   }
   
   const void Game::EPEC::findNashEq() {
     std::stringstream final_msg;
     if (!this->Finalized)
        throw ZEROException(ZEROErrorCode::Assertion, "The EPEC was not Finalized");
   
     if (this->Stats.Status.get() != ZEROStatus::Uninitialized) {
        LOG_S(ERROR) << "Game::EPEC::findNashEq: a Nash Eq was "
                             "already found. Calling this findNashEq might lead to errors!";
     }
   
     // Choosing the appropriate algorithm
     switch (this->Stats.AlgorithmData.Algorithm.get()) {
   
     case Data::EPEC::Algorithms::InnerApproximation: {
        final_msg << "Inner approximation Algorithm completed. ";
        this->Algorithm = std::shared_ptr<Algorithms::EPEC::PolyBase>(
             new class Algorithms::EPEC::InnerApproximation(this->Env, this));
        this->Algorithm->solve();
     } break;
   
     case Data::EPEC::Algorithms::CombinatorialPne: {
        final_msg << "CombinatorialPNE Algorithm completed. ";
        this->Algorithm = std::shared_ptr<Algorithms::EPEC::PolyBase>(
             new class Algorithms::EPEC::CombinatorialPNE(this->Env, this));
        this->Algorithm->solve();
     } break;
   
     case Data::EPEC::Algorithms::OuterApproximation: {
        final_msg << "Outer approximation Algorithm completed. ";
        this->Algorithm = std::shared_ptr<Algorithms::EPEC::PolyBase>(
             new class Algorithms::EPEC::OuterApproximation(this->Env, this));
        this->Algorithm->solve();
     } break;
   
     case Data::EPEC::Algorithms::FullEnumeration: {
        final_msg << "Full enumeration Algorithm completed. ";
        this->Algorithm = std::shared_ptr<Algorithms::EPEC::PolyBase>(
             new class Algorithms::EPEC::FullEnumeration(this->Env, this));
        this->Algorithm->solve();
     } break;
     }
     const std::chrono::duration<double> timeElapsed =
           std::chrono::high_resolution_clock::now() - this->InitTime;
     this->Stats.WallClockTime.set(timeElapsed.count() * std::chrono::milliseconds::period::num /
                                             std::chrono::milliseconds::period::den);
   
     // Handing EPECStatistics object to track performance of algorithm
     if (this->LCPModel) {
        this->Stats.NumVar         = this->LCPModel->get(GRB_IntAttr_NumVars);
        this->Stats.NumConstraints = this->LCPModel->get(GRB_IntAttr_NumConstrs);
        this->Stats.NumNonZero     = this->LCPModel->get(GRB_IntAttr_NumNZs);
     } // Assigning appropriate Status messages after solving
   
     switch (this->Stats.Status.get()) {
     case ZEROStatus::NashEqNotFound:
        final_msg << "No Nash equilibrium exists.";
        break;
     case ZEROStatus::NashEqFound: {
        final_msg << "Found a Nash equilibrium ("
                     << (this->Stats.PureNashEquilibrium.get() == 0 ? "MNE" : "PNE") << ").";
     } break;
     case ZEROStatus::TimeLimit:
        final_msg << "Nash equilibrium not found. Time limit attained";
        break;
     case ZEROStatus::Numerical:
        final_msg << "Nash equilibrium not found. Numerical issues might affect "
                         "this result.";
        break;
     default:
        final_msg << "Nash equilibrium not found. Time limit attained";
        break;
     }
     LOG_S(INFO) << "Game::EPEC::findNashEq: " << final_msg.str();
   }
   
   void Game::EPEC::setAlgorithm(Data::EPEC::Algorithms algorithm)
   {
     this->Stats.AlgorithmData.Algorithm.set(algorithm);
   }
   
   void Game::EPEC::setRecoverStrategy(Data::EPEC::RecoverStrategy strategy)
   {
     this->Stats.AlgorithmData.RecoverStrategy.set(strategy);
   }
   
   unsigned int Game::EPEC::getPositionLeadFoll(const unsigned int i, const unsigned int j) const {
     const auto LeaderStart = this->TheNashGame->getPrimalLoc(i);
     return LeaderStart + j;
   }
   
   unsigned int Game::EPEC::getPositionLeadLead(const unsigned int i, const unsigned int j) const {
     const auto LeaderStart = this->TheNashGame->getPrimalLoc(i);
     return LeaderStart + this->PlayersLCP.at(i)->getLStart() + j;
   }
   
   double Game::EPEC::getValLeadFoll(const unsigned int i, const unsigned int j) const {
     if (!this->LCPModel)
        throw ZEROException(ZEROErrorCode::Assertion, "The LCP was not made nor solved");
     return this->LCPModel->getVarByName("x_" + std::to_string(this->getPositionLeadFoll(i, j)))
           .get(GRB_DoubleAttr_X);
   }
   
   double Game::EPEC::getValLeadLead(const unsigned int i, const unsigned int j) const {
     if (!this->LCPModel)
        throw ZEROException(ZEROErrorCode::Assertion, "The LCP was not made nor solved");
     return this->LCPModel->getVarByName("x_" + std::to_string(this->getPositionLeadLead(i, j)))
           .get(GRB_DoubleAttr_X);
   }
   
   std::string std::to_string(const Data::EPEC::Algorithms al) {
     switch (al) {
     case Data::EPEC::Algorithms::FullEnumeration:
        return std::string("FullEnumeration");
     case Data::EPEC::Algorithms::InnerApproximation:
        return std::string("InnerApproximation");
     case Data::EPEC::Algorithms::CombinatorialPne:
        return std::string("CombinatorialPNE");
     case Data::EPEC::Algorithms::OuterApproximation:
        return std::string("OuterApproximation");
     }
     return "";
   }
   
   std::string std::to_string(const Data::EPEC::RecoverStrategy strategy) {
     switch (strategy) {
     case Data::EPEC::RecoverStrategy::IncrementalEnumeration:
        return std::string("IncrementalEnumeration");
     case Data::EPEC::RecoverStrategy::Combinatorial:
        return std::string("Combinatorial");
     }
     return "";
   }
