
.. _program_listing_file_src_games_algorithms_EPEC_epec_outerapproximation.cpp:

Program Listing for File epec_outerapproximation.cpp
====================================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_games_algorithms_EPEC_epec_outerapproximation.cpp>` (``src/games/algorithms/EPEC/epec_outerapproximation.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   /* #############################################
    *             This file is part of
    *                    ZERO
    *
    *             Copyright (c) 2020
    *     Released under the Creative Commons
    *        Zero v1.0 Universal License
    *
    *              Find out more at
    *        https://github.com/ds4dm/ZERO
    * #############################################*/
   
   
   #include "games/algorithms/EPEC/epec_outerapproximation.h"
   
   #include <boost/log/trivial.hpp>
   #include <chrono>
   #include <gurobi_c++.h>
   #include <set>
   #include <string>
   
   bool Algorithms::EPEC::OuterApproximation::isSolved(double tol) const { return this->Feasible; }
   
   
   bool Algorithms::EPEC::OuterApproximation::isFeasible(bool &addedCuts) {
   
   
     // First, we have a NE from Games::computeNashEq
     if (!this->EPECObject->NashEquilibrium)
        return false;
   
     // Then, the feasibility is implied also by the deviations
     bool      result = {true};
     arma::vec bestResponse;
     arma::vec currentPayoffs =
           this->EPECObject->TheNashGame->computeQPObjectiveValues(this->EPECObject->SolutionX, true);
     for (unsigned int i = 0; i < this->EPECObject->NumPlayers; ++i) {
        BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation:: Payoff of " << i << " is "
                                        << currentPayoffs.at(i);
        this->Trees.at(i)->resetFeasibility();
        double val = this->EPECObject->respondSol(bestResponse, i, this->EPECObject->SolutionX);
        if (val == GRB_INFINITY) {
           BOOST_LOG_TRIVIAL(trace) << "Algorithms::EPEC::OuterApproximation:: Unbounded deviation for "
                                            << i;
           addedCuts = false;
           return false;
        }
        // minimization standard
        // @todo check the direction of the inequality
        if (std::abs(currentPayoffs.at(i) - val) > this->Tolerance) {
           // Discrepancy between payoffs! Need to investigate.
           if (currentPayoffs.at(i) - val > this->Tolerance) {
             // It means the current payoff is more than then optimal response. Then
             // this is not a best response. Theoretically, this cannot happen from
             // an outer approximation. This if case is a warning case then
             //@todo can this happen?
   
             BOOST_LOG_TRIVIAL(warning) << "Algorithms::EPEC::OuterApproximation::"
                                                     "isFeasible: No best response for Player "
                                                 << i << " (" << currentPayoffs.at(i) << " vs " << val << ")";
   
             throw ZEROException(ZEROErrorCode::Numeric,
                                        "Invalid payoffs relation (better best response)");
             // throw;
             // throw;
           } else {
             // if ((val - currentPayoffs.at(i) ) > tol)
             // It means the current payoff is less than the optimal response. The
             // approximation is not good, and this point is infeasible. Then, we can
             // generate a value-cut
             arma::vec xMinusI;
             this->EPECObject->getXMinusI(this->EPECObject->SolutionX, i, xMinusI);
             this->addValueCut(i, val, xMinusI);
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::isFeasible: "
                                                 "Value cut at for Player "
                                             << i;
             result = false;
           }
        } else {
           // Here we have a best response whose payoff coincides with the one of the
           // equilibrium. The strategy might not be feasible, though.
           arma::vec xOfI;
           this->EPECObject->getXofI(this->EPECObject->SolutionX, i, xOfI, false);
   
           // Check if we need to add the point to the vertex storage.
           arma::vec vertex = bestResponse.subvec(0, xOfI.size() - 1);
           //@todo debug
           // vertex.print("Best Response");
           if (!Utils::containsRow(*this->Trees.at(i)->getV(), vertex, this->Tolerance)) {
             this->Trees.at(i)->addVertex(vertex);
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::isFeasible: "
                                                 "Adding vertex as of best response for Player "
                                             << i << " (Best Response)";
           } else {
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::isFeasible: "
                                                 "Already known best response for Player "
                                             << i << " (Best Response)";
           }
   
           if (!Utils::isZero(xOfI - bestResponse.subvec(0, xOfI.size() - 1), this->Tolerance)) {
             // Then, if the answers do not coincide, we need to refine the
             // approximation or determine if this strategy is anyhow feasible.
             // We search for a convex combination of best responses so that we can
             // certify the answer is inside the convex-hull (or not).
   
             int budget = 15;
             if (!this->separationOracle(xOfI, this->EPECObject->SolutionX, i, budget, addedCuts)) {
                BOOST_LOG_TRIVIAL(trace) << "Algorithms::EPEC::OuterApproximation::isFeasible: "
                                                     "Oracle gave a negative answer for Player "
                                                 << i;
                result = false;
             }
   
           } else {
             this->Trees.at(i)->setFeasible();
             this->Trees.at(i)->setPure();
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::isFeasible: "
                                                 "Feasible strategy for Player "
                                             << i << " (Best Response)";
           }
        }
     }
     return result;
   }
   
   
   void Algorithms::EPEC::OuterApproximation::updateMembership(const unsigned int &player,
                                                                                   const arma::vec &   xOfI,
                                                                                   bool                normalization) {
   
   
     auto PlayerTree = Trees.at(player);
     MathOpt::getDualMembershipLP(PlayerTree->MembershipLP,
                                            PlayerTree->VertexCounter,
                                            PlayerTree->V,
                                            PlayerTree->RayCounter,
                                            PlayerTree->R,
                                            xOfI,
                                            normalization);
   }
   
   bool Algorithms::EPEC::OuterApproximation::separationOracle(
        arma::vec &xOfI, arma::vec &x, unsigned int player, int budget, bool &addedCuts) {
   
     for (int k = 0; k < budget; ++k) {
        // First, we check whether the point is a convex combination of feasible
        // KNOWN points
   
        auto V = this->Trees.at(player)->V;
   
        //@todo debug
        // xOfI.print("Point to separate: ");
   
        this->updateMembership(player, xOfI, true);
        auto convexModel = *this->Trees.at(player)->MembershipLP;
        convexModel.optimize();
   
        int status = convexModel.get(GRB_IntAttr_Status);
        BOOST_LOG_TRIVIAL(trace) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                             "MermbershipLP status is "
                                         << status;
        if (status == GRB_OPTIMAL && convexModel.get(GRB_IntAttr_SolCount) == 1) {
           convexModel.set(GRB_IntParam_SolutionNumber, 0);
           arma::vec sol(xOfI.size(), arma::fill::zeros);
           for (unsigned int i = 0; i < xOfI.size(); i++)
             sol.at(i) =
                   std::abs(convexModel.getVarByName("y_" + std::to_string(i)).get(GRB_DoubleAttr_X));
   
           if (convexModel.getObjective().getValue() == 0 && sol.max() == 0) {
             // this->Trees.at(player)->addVertex(xOfI);
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                                 "The point is a convex combination of known points! Player "
                                             << player;
   
             this->Trees.at(player)->setFeasible();
   
             arma::vec support;
             support.zeros(this->Trees.at(player)->getVertexCount());
             auto test = convexModel.getVarByName("x").get(GRB_DoubleAttr_X);
             for (unsigned int v = 0; v < this->Trees.at(player)->getVertexCount(); ++v) {
                // abs to avoid misunderstanding with sign conventions
                support.at(v) =
                     convexModel.getConstrByName("V_" + std::to_string(v)).get(GRB_DoubleAttr_Pi);
             }
             //@todo debug
             // support.print("MNE Support: ");
             if (support.max() == 1)
                this->Trees.at(player)->setPure();
             return true;
           }
        }
   
        // Else, the status should be OPTIMAL but without the objective of zero
        if (status == GRB_OPTIMAL) {
           // Get the Farkas' in the form of the unbounded ray of the dual of the
           // dualMembershipLP (the primal)
           BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                               "The point is NOT a convex combination of known points! Found "
                                           << convexModel.get(GRB_IntAttr_SolCount) << " solutions. Player "
                                           << player;
           for (int z = 0; z < convexModel.get(GRB_IntAttr_SolCount); ++z) {
             convexModel.set(GRB_IntParam_SolutionNumber, z);
             arma::vec cutLHS;
             cutLHS.zeros(xOfI.size());
   
             for (unsigned int i = 0; i < xOfI.size(); i++)
                cutLHS.at(i) = convexModel.getVarByName("y_" + std::to_string(i)).get(GRB_DoubleAttr_X);
             //@todo debug
             // cutLHS.print("Separating hyperplane: ");
   
             // Optimize the resulting inequality over the original feasible set
             auto       leaderModel = this->EPECObject->respond(player, x);
             GRBLinExpr expr        = 0;
             for (unsigned int i = 0; i < xOfI.size(); ++i)
                expr += cutLHS.at(i) * leaderModel->getVarByName("x_" + std::to_string(i));
   
             leaderModel->setObjective(expr, GRB_MAXIMIZE);
             leaderModel->update();
             leaderModel->set(GRB_IntParam_InfUnbdInfo, 1);
             leaderModel->set(GRB_IntParam_DualReductions, 0);
             leaderModel->set(GRB_IntParam_OutputFlag, 0);
             leaderModel->write("dat/LeaderModel" + std::to_string(player) + ".lp");
             leaderModel->optimize();
             status = leaderModel->get(GRB_IntAttr_Status);
   
             if (status == GRB_OPTIMAL) {
                double cutV = leaderModel->getObjective().getValue();
                BOOST_LOG_TRIVIAL(trace)
                     << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                         "LeaderModel status = "
                     << std::to_string(status) << " with objective=" << cutV << " for Player " << player;
                arma::vec val  = cutLHS.t() * xOfI; // c^T xOfI
                arma::vec val2 = cutLHS.t() * V.row(0).t();
                BOOST_LOG_TRIVIAL(trace)
                     << "Algorithms::EPEC::OuterApproximation::separationOracle: c^Tv=" << cutV
                     << " -- c^TxOfI=" << val.at(0) << " -- c^TV(0)=" << val2.at(0);
                if (cutV - val.at(0) < -this->Tolerance) {
                   // False, but we have a cut :-)
                   // Ciao Moni
                   cutV              = cutV;
                   arma::sp_mat cutL = Utils::resizePatch(
                        arma::sp_mat{cutLHS}.t(), 1, this->PolyLCP.at(player)->getNumCols());
                   if (this->PolyLCP.at(player)->containsCut(
                             Utils::resizePatch(cutLHS, this->PolyLCP.at(player)->getNumCols()), cutV)) {
                     BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                                         "cut already added for Player "
                                                     << player;
                     // throw;
                     break;
   
                   } else {
                     this->PolyLCP.at(player)->addCustomCuts(cutL, arma::vec{cutV});
                     BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                                         "adding cut for Player "
                                                     << player;
                     addedCuts = true;
                     return false;
                   }
                } else {
                   // We found a new vertex
                   arma::vec v;
                   v.zeros(V.n_cols);
                   for (unsigned int i = 0; i < V.n_cols; ++i) {
                     v[i] = leaderModel->getVarByName("x_" + std::to_string(i)).get(GRB_DoubleAttr_X);
                   }
   
                   //@todo debug
                   // v.print("Vertex found: ");
                   if (Utils::containsRow(*this->Trees.at(player)->getV(), v, this->Tolerance)) {
                     BOOST_LOG_TRIVIAL(warning)
                           << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                               "duplicate vertex for  player "
                           << player;
                     //@todo
                     break;
                     // throw;
                   } else {
                     this->Trees.at(player)->addVertex(v);
                     //@todo debug
                     // v.print("Vertex");
                     BOOST_LOG_TRIVIAL(info)
                           << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                               "adding vertex for Player. "
                           << (budget - k - 1) << " iterations left for player " << player;
                     break;
                   }
                }
   
             } // status optimal for leaderModel
             else if (status == GRB_UNBOUNDED) {
                // Check for a new ray
                if (!Utils::containsRow(*this->Trees.at(player)->getR(), cutLHS, this->Tolerance)) {
                   BOOST_LOG_TRIVIAL(warning) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                                           "new ray for  player "
                                                       << player;
                   this->Trees.at(player)->addRay(cutLHS);
                   break;
                } else {
                   BOOST_LOG_TRIVIAL(warning) << "Algorithms::EPEC::OuterApproximation::separationOracle: "
                                                           "duplicate ray for player "
                                                       << player;
                   break;
                }
   
             } // status unbounded for leaderModel
   
             else
                throw ZEROException(ZEROErrorCode::Assertion,
                                           "Unknown status for leaderModel for player " +
                                                std::to_string(player));
           } // end for
             // no separation
        } else {
           throw ZEROException(ZEROErrorCode::Assertion,
                                     "Unknown status for convexModel for player " + std::to_string(player));
        }
     }
     return false;
   }
   
   
   void Algorithms::EPEC::OuterApproximation::addValueCut(const unsigned int player,
                                                                            const double       RHS,
                                                                            arma::vec          xMinusI) {
   
     arma::vec LHS = this->EPECObject->LeaderObjective.at(player)->c +
                           this->EPECObject->LeaderObjective.at(player)->C * xMinusI;
     arma::sp_mat cutLHS =
           Utils::resizePatch(arma::sp_mat{LHS}.t(), 1, this->PolyLCP.at(player)->getNumCols());
     BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::addValueCut: "
                                         "adding cut for Player "
                                     << player;
     if (!this->PolyLCP.at(player)->containsCut(LHS, -RHS, this->Tolerance))
        this->PolyLCP.at(player)->addCustomCuts(-cutLHS, arma::vec{-RHS});
   }
   
   void Algorithms::EPEC::OuterApproximation::solve() {
     // Set the initial point for all countries as 0 and solve the respective LCPs?
     this->EPECObject->SolutionX.zeros(this->EPECObject->NumVariables);
     bool solved = {false};
     if (this->EPECObject->Stats.AlgorithmData.TimeLimit.get() > 0)
        this->EPECObject->InitTime = std::chrono::high_resolution_clock::now();
   
     this->EPECObject->Stats.NumIterations.set(0);
   
     // Initialize Trees
     this->Trees     = std::vector<OuterTree *>(this->EPECObject->NumPlayers, 0);
     this->Incumbent = std::vector<OuterTree::Node *>(this->EPECObject->NumPlayers, 0);
     for (unsigned int i = 0; i < this->EPECObject->NumPlayers; i++) {
        Trees.at(i)     = new OuterTree(this->PolyLCP.at(i)->getNumRows(), this->Env);
        Incumbent.at(i) = Trees.at(i)->getRoot();
     }
   
     bool branch = true;
     int  comp   = 0;
     // In this case, branchingLocations is a vector of locations with the length
     // of this->EPECObject->NumPlayers
     std::vector<int>      branchingLocations;
     std::vector<long int> branches;
     while (!solved) {
        branchingLocations.clear();
        this->EPECObject->Stats.NumIterations.set(this->EPECObject->Stats.NumIterations.get() + 1);
        BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: Iteration "
                                        << std::to_string(this->EPECObject->Stats.NumIterations.get());
   
        comp               = 0;
        branchingLocations = std::vector<int>(this->EPECObject->NumPlayers, -1);
   
        if (branch) {
           for (int j = 0; j < this->EPECObject->NumPlayers; ++j) {
             if (Incumbent.at(j)->getCumulativeBranches() == Trees.at(j)->getEncodingSize())
                comp++;
             else {
                if (this->EPECObject->Stats.NumIterations.get() == 1) {
                   branchingLocations.at(j) = this->getFirstBranchLocation(j, Incumbent.at(j));
                } else {
                   branchingLocations.at(j) = this->hybridBranching(j, Incumbent.at(j));
                }
             }
           }
   
           // Check at least a player has at least a branching candidate
           if (comp == this->EPECObject->NumPlayers) {
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                 "Solved without any equilibrium.";
             this->EPECObject->Stats.Status.set(ZEROStatus::NashEqNotFound);
             solved = true;
             break;
           }
   
           // Check that there is at least a player has a branching selection with
           // hybrid branching
           if (*std::max_element(branchingLocations.begin(), branchingLocations.end()) < 0) {
   
             // No branching candidates.
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                 "No more hybrid branching candidates for "
                                                 "any player. Checking if "
                                                 "any complementarities are left.";
             this->printCurrentApprox();
             for (int j = 0; j < this->EPECObject->NumPlayers; ++j)
                branchingLocations.at(j) = this->getFirstBranchLocation(j, Incumbent.at(j));
   
             if (*std::max_element(branchingLocations.begin(), branchingLocations.end()) < 0) {
                BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                    "No more branching candidates.";
                this->EPECObject->Stats.Status.set(ZEROStatus::NashEqNotFound);
                break;
             }
           }
        }
   
        for (int j = 0; j < this->EPECObject->NumPlayers; ++j) {
           if (branchingLocations.at(j) > -1) {
             branches           = Trees.at(j)->singleBranch(branchingLocations.at(j), *Incumbent.at(j));
             auto childEncoding = this->Trees.at(j)->getNodes()->at(branches.at(0)).getEncoding();
             this->PolyLCP.at(j)->outerApproximate(childEncoding, true);
             // By definition of hybrid branching, the node should be feasible
             Incumbent.at(j) = &(this->Trees.at(j)->getNodes()->at(branches.at(0)));
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                 "branching candidate for player "
                                             << j << " is " << branchingLocations.at(j);
           } else if (!branch) {
             // if we don't branch.
             this->PolyLCP.at(j)->outerApproximate(Incumbent.at(j)->getEncoding(), true);
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                 "No branching for player "
                                             << j;
           }
        }
   
        this->printCurrentApprox();
        this->EPECObject->makePlayersQPs();
        // To make computeNashEq skip any feasibility check
        this->Feasible = true;
        if (this->EPECObject->Stats.AlgorithmData.TimeLimit.get() > 0) {
           const std::chrono::duration<double> timeElapsed =
                std::chrono::high_resolution_clock::now() - this->EPECObject->InitTime;
           const double timeRemaining =
                this->EPECObject->Stats.AlgorithmData.TimeLimit.get() - timeElapsed.count();
           this->EPECObject->computeNashEq(
                this->EPECObject->Stats.AlgorithmData.PureNashEquilibrium.get(), timeRemaining);
        } else {
           this->EPECObject->computeNashEq(
                this->EPECObject->Stats.AlgorithmData.PureNashEquilibrium.get());
        }
   
        this->Feasible = false;
        if (this->EPECObject->NashEquilibrium) {
           bool addedCuts{false};
           if (this->isFeasible(addedCuts)) {
             this->Feasible = true;
             this->EPECObject->Stats.Status.set(ZEROStatus::NashEqFound);
             BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                 "Solved. ";
             return;
           } else {
             if (addedCuts) {
                branch = false;
                BOOST_LOG_TRIVIAL(info) << "Algorithms::EPEC::OuterApproximation::solve: "
                                                    "Cuts were added. Skipping next branching phase. ";
             } else {
                branch = true;
             }
           }
        } else {
           branch = true;
        }
        if (this->EPECObject->Stats.AlgorithmData.TimeLimit.get() > 0) {
           const std::chrono::duration<double> timeElapsed =
                std::chrono::high_resolution_clock::now() - this->EPECObject->InitTime;
           const double timeRemaining =
                this->EPECObject->Stats.AlgorithmData.TimeLimit.get() - timeElapsed.count();
           if (timeRemaining <= 0) {
             this->EPECObject->Stats.Status.set(ZEROStatus::TimeLimit);
             return;
           }
        }
     }
   }
   
   
   std::unique_ptr<GRBModel> Algorithms::EPEC::OuterApproximation::getFeasQP(const unsigned int player,
                                                                                                     const arma::vec    x) {
   
   
     // this->EPECObject->getXMinusI(this->EPECObject->SolutionX, player, xMinusI);
     arma::vec zeros;
     // Dummy vector of zeros associated to x^{-i}
     zeros.zeros(this->EPECObject->PlayersQP.at(player)->getNx());
     auto model = this->EPECObject->PlayersQP.at(player)->solveFixed(zeros, false);
     // Enforce QP::y to be x, namely the point to belong to the feasible region
     for (unsigned int j = 0; j < x.size(); j++)
        model->addConstr(model->getVarByName("y_" + std::to_string(j)),
                               GRB_EQUAL,
                               x.at(j),
                               "Fix_y_" + std::to_string(j));
     // Reset the objective
     model->setObjective(GRBLinExpr{0}, GRB_MINIMIZE);
     // model->write("dat/test.lp");
     return model;
   }
   
   
   int Algorithms::EPEC::OuterApproximation::hybridBranching(const unsigned int player,
                                                                                OuterTree::Node *  node) {
   
     BOOST_LOG_TRIVIAL(info) << "OuterApproximation::hybridBranching: Player " << player;
   
     int bestId = -1;
     if (this->EPECObject->NashEquilibrium) {
        arma::vec zeros, x;
   
        this->EPECObject->getXofI(this->EPECObject->SolutionX, player, x);
        if (x.size() != this->EPECObject->LeaderObjective.at(player)->c.n_rows)
           throw ZEROException(ZEROErrorCode::Assertion, "wrong dimensioned x^i");
   
        auto              currentEncoding = node->getEncoding();
        std::vector<bool> incumbentApproximation;
        double            bestScore = -1.0;
   
        for (unsigned int i = 0; i < currentEncoding.size(); i++) {
           // For each complementarity
           if (node->getAllowedBranchings().at(i)) {
             // Consider it if it is a good candidate for branching (namely, we
             // didn't branch on it, or it wasn't proven to be infeasible)
             incumbentApproximation = currentEncoding;
             // Include this complementarity in the approximation
             incumbentApproximation.at(i) = true;
             // Build the approximation
             this->PolyLCP.at(player)->outerApproximate(incumbentApproximation, true);
             // If the approximation is infeasible, prune this branching location
             // from the candidates
             if (!this->PolyLCP.at(player)->getFeasOuterApp())
                Trees.at(player)->denyBranchingLocation(*node, i);
             else {
                // In this case, we can check if the solution belongs to the outer
                // approximation
                this->EPECObject->makePlayerQP(player);
                // Get the QP model with other players decision QP::x fixed to zero
                // (since they only appear in the objective);
                auto model = this->getFeasQP(player, x);
                model->optimize();
                const int status = model->get(GRB_IntAttr_Status);
                if (status == GRB_INFEASIBLE) {
                   // If the status is infeasible, bingo! We want to get a measure of
                   // the constraint violations given by the current x
                   model->feasRelax(0, false, false, true);
                   model->optimize();
                   if (model->getObjective().getValue() > bestScore) {
                     bestId    = i;
                     bestScore = model->getObjective().getValue();
                     BOOST_LOG_TRIVIAL(debug)
                           << "OuterApproximation::hybridBranching: Player " << player
                           << " has violation of " << bestScore << " with complementarity " << i;
                   }
                } else {
                   BOOST_LOG_TRIVIAL(debug) << "OuterApproximation::hybridBranching: Player " << player
                                                    << " has no violation with complementarity " << i;
                }
             }
           }
        }
     }
     return bestId;
   }
   
   
   
   int Algorithms::EPEC::OuterApproximation::infeasibleBranching(const unsigned int     player,
                                                                                     const OuterTree::Node *node) {
   
     int result = -1;
     if (this->EPECObject->NashEquilibrium) {
        // There exists a Nash Equilibrium for the outer approximation, which is not
        // a Nash Equilibrium for the game
        arma::vec x, z;
        this->EPECObject->getXWithoutHull(this->EPECObject->SolutionX, x);
        z                                      = this->PolyLCP.at(player)->zFromX(x);
        std::vector<short int> currentSolution = this->PolyLCP.at(player)->solEncode(x);
   
        double maxInfeas = 0;
   
        //"The most infeasible" branching
        for (unsigned int i = 0; i < currentSolution.size(); i++) {
           unsigned int varPos = i >= this->PolyLCP.at(player)->getLStart()
                                             ? i + this->PolyLCP.at(player)->getNumberLeader()
                                             : i;
           if (x(varPos) > 0 && z(i) > 0 && node->getAllowedBranchings().at(i) &&
                currentSolution.at(i) == 0) {
             if ((x(varPos) + z(i)) > maxInfeas) {
                maxInfeas = x(varPos) + z(i);
                result    = i;
             }
           }
        }
     }
     return result;
   }
   
   int Algorithms::EPEC::OuterApproximation::deviationBranching(const unsigned int     player,
                                                                                    const OuterTree::Node *node) {
   
   
     int result = -1;
     if (this->EPECObject->NashEquilibrium) {
        // There exists a Nash Equilibrium for the outer approximation, which is not
        // a Nash Equilibrium for the game
        arma::vec dev;
        arma::vec x;
        this->EPECObject->getXWithoutHull(this->EPECObject->SolutionX, x);
        std::vector<short int> currentSolution = this->PolyLCP.at(player)->solEncode(x);
        this->EPECObject->respondSol(dev, player, this->EPECObject->SolutionX);
        auto encoding = this->PolyLCP.at(player)->solEncode(dev);
   
        for (unsigned int i = 0; i < encoding.size(); i++) {
           if (encoding.at(i) > 0 && node->getAllowedBranchings().at(i) && currentSolution.at(i) == 0) {
             result = i;
           }
        }
     }
     return result;
   }
   
   
   int Algorithms::EPEC::OuterApproximation::getFirstBranchLocation(const unsigned int     player,
                                                                                         const OuterTree::Node *node) {
     if (node->getCumulativeBranches() == Trees.at(player)->getEncodingSize())
        return -1;
     auto         model = this->PolyLCP.at(player)->LCPasMIP(true);
     unsigned int nR    = this->PolyLCP.at(player)->getNumRows();
     int          pos   = -nR;
     arma::vec    z, x;
     if (this->PolyLCP.at(player)->extractSols(
                model.get(), z, x, true)) // If already infeasible, nothing to branch!
     {
        std::vector<short int> v1 = this->PolyLCP.at(player)->solEncode(z, x);
   
        double       maxvalx{-1}, maxvalz{-1};
        unsigned int maxposx{0}, maxposz{0};
        for (unsigned int i = 0; i < nR; i++) {
           unsigned int varPos = i >= this->PolyLCP.at(player)->getLStart()
                                             ? i + this->PolyLCP.at(player)->getNumberLeader()
                                             : i;
           if (x(varPos) > maxvalx && node->getAllowedBranchings().at(i)) {
             maxvalx = x(varPos);
             maxposx = i;
           }
           if (z(i) > maxvalz && node->getAllowedBranchings().at(i)) {
             maxvalz = z(i);
             maxposz = i;
           }
        }
        pos = maxvalz > maxvalx ? maxposz : maxposx;
     } else {
        // The problem is infeasible!
        return -1;
     }
     return pos;
   }
   
   
   
   std::vector<int>
   Algorithms::EPEC::OuterApproximation::getNextBranchLocation(const unsigned int player,
                                                                                   OuterTree::Node *  node) {
   
     std::vector<int> decisions = {-1, -1, -1, -1};
     decisions.at(0)            = this->infeasibleBranching(player, node);
     decisions.at(1)            = this->deviationBranching(player, node);
     decisions.at(2)            = this->hybridBranching(player, node);
   
     if (decisions.at(0) < 0 && decisions.at(1) < 0 && decisions.at(2) < 0) {
        BOOST_LOG_TRIVIAL(info) << "Player " << player
                                        << ": branching with FirstBranchLocation is the only available choice";
        decisions.at(3) = this->getFirstBranchLocation(player, node);
     }
   
     BOOST_LOG_TRIVIAL(debug) << "Algorithms::EPEC::OuterApproximation::getNextBranchinglocation: "
                                           "given decisions are: ";
     BOOST_LOG_TRIVIAL(debug) << "Algorithms::EPEC::OuterApproximation::"
                                           "getNextBranchinglocation:\t Infeasible="
                                       << decisions.at(0);
     BOOST_LOG_TRIVIAL(debug) << "Algorithms::EPEC::OuterApproximation::"
                                           "getNextBranchinglocation:\t Deviation="
                                       << decisions.at(1);
     BOOST_LOG_TRIVIAL(debug) << "Algorithms::EPEC::OuterApproximation::"
                                           "getNextBranchinglocation:\t Hybrid="
                                       << decisions.at(2);
     BOOST_LOG_TRIVIAL(debug) << "Algorithms::EPEC::OuterApproximation::"
                                           "getNextBranchinglocation:\t First="
                                       << decisions.at(3);
     return decisions;
   }
   
   
   void Algorithms::EPEC::OuterApproximation::printCurrentApprox() {
     BOOST_LOG_TRIVIAL(info) << "Current Node Approximation:";
     for (unsigned int p = 0; p < this->EPECObject->NumPlayers; ++p) {
        std::stringstream msg;
        msg << "\tPlayer " << p << ":";
        for (unsigned int i = 0; i < this->Incumbent.at(p)->getEncoding().size(); i++) {
           msg << "\t" << this->Incumbent.at(p)->getEncoding().at(i);
        }
        BOOST_LOG_TRIVIAL(info) << msg.str();
     }
   }
   
   void Algorithms::EPEC::OuterApproximation::printBranchingLog(std::vector<int> vector) {
     BOOST_LOG_TRIVIAL(info) << "Current Branching Log:";
     BOOST_LOG_TRIVIAL(info) << "\tInfeasibleBranching: " << vector.at(0);
     BOOST_LOG_TRIVIAL(info) << "\tDeviationBranching: " << vector.at(1);
     BOOST_LOG_TRIVIAL(info) << "\tHybridBranching: " << vector.at(2);
     BOOST_LOG_TRIVIAL(info) << "\tFirstAvail: " << vector.at(3);
   }
   
   bool Algorithms::EPEC::OuterApproximation::isPureStrategy(double tol) const {
     if (!this->Feasible)
        return false;
     else {
        for (unsigned int i = 0; i < this->EPECObject->NumPlayers; ++i)
           if (!Trees.at(i)->getPure())
             return false;
   
        return true;
     }
   }
   
   
   
   Algorithms::EPEC::OuterTree::Node::Node(Node &parent, unsigned int idComp, unsigned long int id) {
     this->IdComps                      = std::vector<unsigned int>{idComp};
     this->Encoding                     = parent.Encoding;
     this->Encoding.at(idComp)          = true;
     this->AllowedBranchings            = parent.AllowedBranchings;
     this->AllowedBranchings.at(idComp) = false;
     this->Id                           = id;
     this->Parent                       = &parent;
   }
   
   Algorithms::EPEC::OuterTree::Node::Node(unsigned int encSize) {
     this->Encoding          = std::vector<bool>(encSize, 0);
     this->Id                = 0;
     this->AllowedBranchings = std::vector<bool>(encSize, true);
   }
   
   
   void Algorithms::EPEC::OuterTree::denyBranchingLocation(Algorithms::EPEC::OuterTree::Node &node,
                                                                             const unsigned int &location) {
     if (location >= this->EncodingSize)
        throw ZEROException(ZEROErrorCode::OutOfRange, "idComp is larger than the encoding size");
     if (!node.AllowedBranchings.at(location))
        BOOST_LOG_TRIVIAL(warning) << "Algorithms::EPEC::OuterTree::denyBranchingLocation: location "
                                                "has been already denied.";
     node.AllowedBranchings.at(location) = false;
   }
   
   
   std::vector<long int>
   Algorithms::EPEC::OuterTree::singleBranch(const unsigned int                 idComp,
                                                           Algorithms::EPEC::OuterTree::Node &t) {
     if (idComp >= this->EncodingSize)
        throw ZEROException(ZEROErrorCode::OutOfRange, "idComp is larger than the encoding size");
     if (t.Encoding.at(idComp) != 0) {
        BOOST_LOG_TRIVIAL(warning)
             << "OuterTree: cannot branch on this complementary, since it already "
                 "has been processed.";
        return std::vector<long int>{-1};
     }
     auto child = Node(t, idComp, this->nextIdentifier());
   
     this->Nodes.push_back(child);
     return std::vector<long int>{this->NodeCounter - 1};
   }
   
   void Algorithms::EPEC::OuterTree::addVertex(arma::vec vertex) {
     if (vertex.size() != this->V.n_cols && this->V.n_rows > 0)
        throw ZEROException(ZEROErrorCode::OutOfRange, "Ill-dimensioned vertex");
     this->V = arma::join_cols(this->V, arma::sp_mat{vertex.t()});
   }
   
   void Algorithms::EPEC::OuterTree::addRay(arma::vec ray) {
     if (ray.size() != this->R.n_cols && this->R.n_rows > 0)
        throw ZEROException(ZEROErrorCode::OutOfRange, "Ill-dimensioned ray");
     this->R = arma::join_cols(this->R, arma::sp_mat{ray.t()});
   }
   
   Algorithms::EPEC::OuterTree::Node::Node(Node &            parent,
                                                        std::vector<int>  idsComp,
                                                        unsigned long int id) {
     this->IdComps           = std::vector<unsigned int>();
     this->Encoding          = parent.Encoding;
     this->AllowedBranchings = parent.AllowedBranchings;
     for (auto &idComp : idsComp) {
        if (idComp < 0)
           throw ZEROException(ZEROErrorCode::Assertion, "idComp is negative");
        this->Encoding.at(idComp)          = true;
        this->AllowedBranchings.at(idComp) = false;
        this->IdComps.push_back(idComp);
     }
     this->Id     = id;
     this->Parent = &parent;
   }
