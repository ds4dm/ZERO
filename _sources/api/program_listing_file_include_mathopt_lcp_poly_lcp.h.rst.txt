
.. _program_listing_file_include_mathopt_lcp_poly_lcp.h:

Program Listing for File poly_lcp.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_mathopt_lcp_poly_lcp.h>` (``include/mathopt/lcp/poly_lcp.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   /* #############################################
    *             This file is part of
    *                    ZERO
    *
    *             Copyright (c) 2020
    *     Released under the Creative Commons
    *        Zero v1.0 Universal License
    *
    *              Find out more at
    *        https://github.com/ds4dm/ZERO
    * #############################################*/
   
   
   #pragma once
   #include "zero.h"
   #include <armadillo>
   #include <array>
   #include <gurobi_c++.h>
   #include <iostream>
   #include <memory>
   #include <set>
   #include <string>
   
   namespace MathOpt {
     class PolyLCP : public LCP {
   
     private:
        bool Outer_FeasibleApproximation =
             false; 
   
   
        unsigned int Inner_SequentialPolyCounter{0};
   
        long int Inner_ReverseSequentialPolyCounter{0};
   
   
        std::array<std::set<unsigned long int>, 2> CurrentPoly = {};
   
        std::array<std::set<unsigned long int>, 2> FeasiblePoly = {};
   
        std::array<std::set<unsigned long int>, 2> InfeasiblePoly = {};
   
        unsigned long int Inner_MaxPoly{0};
   
        void initializeSizes() {
           // 2^n - the number of polyhedra theoretically
           this->Inner_MaxPoly         = static_cast<unsigned long int>(pow(2, this->Compl.size()));
           Inner_SequentialPolyCounter = 0;
           Inner_ReverseSequentialPolyCounter = this->Inner_MaxPoly - 1;
        }
   
   
        bool              addPolyFromEncoding(std::vector<short int> encoding,
                                                           bool                   innerApproximation = true,
                                                           bool                   checkFeas          = false,
                                                           bool                   custom             = false,
                                                           spmat_Vec *            custAi             = {},
                                                           vec_Vec *              custbi             = {});
        PolyLCP &         addPoliesFromEncoding(std::vector<short int> encoding,
                                                             bool                   innerApproximation = true,
                                                             bool                   checkFeas          = false,
                                                             bool                   custom             = false,
                                                             spmat_Vec *            custAi             = {},
                                                             vec_Vec *              custbi             = {});
        unsigned long int getNextPoly(Data::LCP::PolyhedraStrategy method);
   
     public:
        PolyLCP(GRBEnv *env, const Game::NashGame &N) : LCP(env, N) {
           this->Ai = std::unique_ptr<spmat_Vec>(new spmat_Vec());
           this->bi = std::unique_ptr<vec_Vec>(new vec_Vec());
           this->initializeSizes();
        };
   
        long int RandomSeed = {-1}; 
   
   
   
        unsigned long int getNumTheoreticalPoly() const noexcept {
           return this->Inner_MaxPoly;
        } 
        bool getFeasOuterApp() const {
           return this->Outer_FeasibleApproximation;
        } 
   
        std::array<std::set<unsigned long int>, 2> getAllPolyhedra() const {
           return this->CurrentPoly;
        }; 
        void                   clearPolyhedra(bool inner);
        unsigned long          convNumPoly(bool innerApproximation) const;
        std::vector<short int> solEncode(const arma::vec &z, const arma::vec &x) const;
        std::vector<short int> solEncode(const arma::vec &x) const;
        unsigned int convPolyPosition(const unsigned long int i, bool innerApproximation) const;
        unsigned int convPolyWeight(const unsigned long int i, bool innerApproximation) const;
        unsigned int
                         addAPoly(unsigned long int            nPoly = 1,
                                     Data::LCP::PolyhedraStrategy method = Data::LCP::PolyhedraStrategy::Sequential);
        bool         addThePoly(const unsigned long int &decimalEncoding, bool innerApproximation);
        bool         checkPolyFeas(const unsigned long int &decimalEncoding, bool innerApproximation);
        bool         checkPolyFeas(const std::vector<short int> &encoding, bool innerApproximation);
        bool         addPolyFromX(const arma::vec &x, bool innerApproximation);
        unsigned int exactFullEnumeration(bool feasibilityCheck = true);
        std::string  feasabilityDetailString() const;
        void         outerApproximate(std::vector<bool> encoding, bool clear = true);
        unsigned int getFeasiblePolyhedra() const { return this->FeasiblePoly[0].size(); }
   
        std::vector<short> numToVec(unsigned long number, const unsigned long nCompl, bool inner);
        unsigned long      vecToNum(std::vector<short> binary, bool inner);
     };
   } // namespace MathOpt
