
.. _program_listing_file_include_mathopt_lcp_lcp.h:

Program Listing for File lcp.h
==============================

|exhale_lsh| :ref:`Return to documentation for file <file_include_mathopt_lcp_lcp.h>` (``include/mathopt/lcp/lcp.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   /* #############################################
    *             This file is part of
    *                    ZERO
    *
    *             Copyright (c) 2020
    *     Released under the Creative Commons
    *        Zero v1.0 Universal License
    *
    *              Find out more at
    *        https://github.com/ds4dm/ZERO
    * #############################################*/
   
   
   #pragma once
   
   
   #include "zero.h"
   #include <armadillo>
   #include <gurobi_c++.h>
   #include <iostream>
   #include <memory>
   #include <set>
   
   namespace Data {
     namespace LCP {
   
        enum class PolyhedraStrategy {
           Sequential        = 0, 
           ReverseSequential = 1, 
           Random = 2 
        };
        enum class Algorithms {
           MIP,  
           PATH, 
           MINLP 
        };
     } // namespace LCP
   } // namespace Data
   
   namespace MathOpt {
   
     class LCP {
   
     protected:
        // Essential data ironment for MIP/LP solves
        GRBEnv *     Env; 
        arma::sp_mat M;   
        arma::vec    q;   
        perps Compl; 
        unsigned int LeadStart{1}, LeadEnd{0}, NumberLeader{0};
        bool         PureMIP = true; 
        arma::sp_mat A     = {}; 
        arma::vec    b     = {}; 
        arma::sp_mat _Acut = {}; 
        arma::vec    _bcut = {}; 
        bool         MadeRlxdModel{false}; 
        unsigned int nR, nC;               
   
        VariableBounds BoundsX;
   
        GRBModel RelaxedModel; 
   
        void defConst(GRBEnv *env);
   
        void makeRelaxed();
   
        std::unique_ptr<GRBModel> getMIP();
   
        std::unique_ptr<GRBModel> getMINLP();
   
        std::unique_ptr<spmat_Vec> Ai;
        std::unique_ptr<vec_Vec> bi;
   
        unsigned int convexHull(arma::sp_mat &A, arma::vec &b);
   
     public:
        double Eps{1e-6}; 
   
        LCP() = delete;
   
   
        explicit LCP(GRBEnv *e) : Env{e}, RelaxedModel(*e){};
        LCP(GRBEnv *     env,
             arma::sp_mat M,
             arma::vec    q,
             unsigned int leadStart,
             unsigned     leadEnd,
             arma::sp_mat A = {},
             arma::vec    b = {});
        LCP(GRBEnv *     env,
             arma::sp_mat M,
             arma::vec    q,
             perps        Compl,
             arma::sp_mat A = {},
             arma::vec    b = {});
   
        LCP(GRBEnv *env, const Game::NashGame &N);
   
        ~LCP() = default;
   
        // Fields getters
        inline arma::sp_mat  getM() const { return this->M; }  
        inline arma::sp_mat *getMstar() { return &(this->M); } 
        inline arma::vec     getq() const { return this->q; }  
        inline unsigned int  getNumberLeader() const {
         return this->NumberLeader;
        } 
        inline arma::vec *        getqstar() { return &(this->q); } 
        const inline unsigned int getLStart() const {
           return LeadStart;
        } 
        const inline unsigned int getLEnd() const {
           return LeadEnd;
        } 
        inline perps        getCompl() const { return this->Compl; } 
        inline unsigned int getNumCols() const { return this->nC; }; 
        inline unsigned int getNumRows() const { return this->nR; }; 
   
   
        inline bool hasCommonConstraints() const {
           return this->A.n_nonzero > 0;
        }; 
   
   
        bool extractSols(GRBModel *model, arma::vec &z, arma::vec &x, bool extractZ = false) const;
   
        ZEROStatus solve(Data::LCP::Algorithms algo, arma::vec &x, arma::vec &z, double timeLimit = -1);
   
        std::unique_ptr<GRBModel> LCPasMIP(bool solve = false);
   
        std::unique_ptr<GRBModel> MPECasMILP(const arma::sp_mat &C,
                                                         const arma::vec &   c,
                                                         const arma::vec &   x_minus_i,
                                                         bool                solve = false);
   
   
        std::unique_ptr<GRBModel> MPECasMIQP(const arma::sp_mat &Q,
                                                         const arma::sp_mat &C,
                                                         const arma::vec &   c,
                                                         const arma::vec &   x_minus_i,
                                                         bool                solve = false);
   
   
        ZEROStatus solvePATH(double timelimit, arma::vec &x, arma::vec &z, bool verbose = true);
   
        void save(std::string filename, bool erase = true) const;
   
        long int load(std::string filename, long int pos = 0);
   
        virtual void makeQP(MathOpt::QP_Objective &QP_obj, MathOpt::QP_Param &QP);
   
        void addCustomCuts(const arma::sp_mat A, const arma::vec b);
   
        bool containsCut(const arma::vec LHS, const double RHS, double tol = 1e-5);
   
        arma::vec zFromX(const arma::vec x);
   
        void processBounds();
     };
   } // namespace MathOpt
   
   namespace std {
     string to_string(Data::LCP::PolyhedraStrategy add);
   }
   
   #include "poly_lcp.h"
