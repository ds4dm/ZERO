
.. _program_listing_file_include_games_algorithms_EPEC_epec_outerapproximation.h:

Program Listing for File epec_outerapproximation.h
==================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_games_algorithms_EPEC_epec_outerapproximation.h>` (``include/games/algorithms/EPEC/epec_outerapproximation.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: none

   /* #############################################
    *             This file is part of
    *                    ZERO
    *
    *             Copyright (c) 2020
    *     Released under the Creative Commons
    *        Zero v1.0 Universal License
    *
    *              Find out more at
    *        https://github.com/ds4dm/ZERO
    * #############################################*/
   
   
   #pragma once
   
   #include "epec_polybase.h"
   #include "zero.h"
   #include <armadillo>
   #include <gurobi_c++.h>
   #include <iostream>
   #include <memory>
   #include <set>
   #include <string>
   
   namespace Algorithms {
     namespace EPEC {
   
        class OuterTree {
        public:
           friend Algorithms::EPEC::OuterApproximation;
           struct Node {
           public:
             friend class OuterTree;
   
             Node(unsigned int encSize);
   
             Node(Node &parent, unsigned int idComp, unsigned long int id);
             Node(Node &parent, std::vector<int> idComps, unsigned long int id);
   
             inline unsigned long int getCumulativeBranches() const {
                return std::count(this->AllowedBranchings.begin(), this->AllowedBranchings.end(), false);
             }
   
             inline std::vector<bool> getEncoding() const {
                return this->Encoding;
             } 
   
             inline std::vector<bool> getAllowedBranchings() const {
                return this->AllowedBranchings;
             } 
   
   
           private:
             std::vector<unsigned int> IdComps; 
   
             std::vector<bool> Encoding;
   
             std::vector<bool> AllowedBranchings;
             unsigned long int Id;     
             Node *            Parent; 
           };
   
        private:
           Node         Root         = Node(0); 
           unsigned int EncodingSize = 0;       
           unsigned int NodeCounter = 1; 
   
           std::vector<Node> Nodes{};
           bool isPure{false}; 
           bool isFeasible{
                false}; 
   
           unsigned int nextIdentifier() {
             this->NodeCounter++;
             return (this->NodeCounter - 1);
           } 
   
        protected:
           std::unique_ptr<GRBModel> MembershipLP;
   
           arma::sp_mat V{};
           arma::sp_mat R{}; 
           unsigned int VertexCounter = 0; 
           unsigned int RayCounter    = 0; 
   
        public:
           OuterTree(unsigned int encSize, GRBEnv *env) : MembershipLP(new GRBModel(*env)) {
             this->Root         = Node(encSize);
             this->EncodingSize = encSize;
             this->Nodes.push_back(this->Root);
           } 
   
   
           inline void resetFeasibility() {
             this->isPure     = false;
             this->isFeasible = false;
           } 
   
           inline bool getPure() const {
             return this->isPure;
           } 
   
           inline void setFeasible() {
             this->isFeasible = true;
           } 
   
           inline void setPure() { this->isPure = true; } 
   
           const inline unsigned int getEncodingSize() {
             return this->EncodingSize;
           } 
   
           inline const arma::sp_mat *getV() { return &this->V; } 
   
           inline const arma::sp_mat *getR() { return &this->R; } 
   
           inline const unsigned int getVertexCount() {
             return this->VertexCounter;
           } 
           inline const unsigned int getRayCount() {
             return this->RayCounter;
           } 
   
           inline const unsigned int getNodeCount() {
             return this->NodeCounter;
           } 
   
   
           inline void addVertex(arma::vec vertex);
   
           inline void addRay(arma::vec ray);
   
           inline Node *const getRoot() { return &this->Root; } 
   
           inline std::vector<Node> *getNodes() { return &this->Nodes; }; 
   
           void denyBranchingLocation(Node &node, const unsigned int &location);
   
           std::vector<long int> singleBranch(const unsigned int idComp, Node &t);
        };
   
        class OuterApproximation : public PolyBase {
   
        public:
           OuterApproximation(GRBEnv *env, Game::EPEC *EPECObject) : PolyBase(env, EPECObject){};
           double getTol() const {
             return this->Tolerance;
           } 
           void setTol(double tol) {
             this->Tolerance = tol;
           } 
   
           void solve() override;
           void printCurrentApprox();
           void printBranchingLog(std::vector<int> vector);
   
           //@todo define these for the outer approximation
           bool isSolved(double tol = 1e-4) const;
           bool isFeasible(bool &addedCuts);
           bool isPureStrategy(double tol = 1e-4) const;
   
   
        private:
           std::vector<OuterTree *>       Trees; 
           std::vector<OuterTree::Node *> Incumbent; 
           bool   Feasible{false};                   
           double Tolerance = 1e-6;                  
   
           std::vector<int> getNextBranchLocation(const unsigned int player, OuterTree::Node *node);
           int getFirstBranchLocation(const unsigned int player, const OuterTree::Node *node);
   
        protected:
           void postSolving(){
                //@todo implement
           };
   
           void updateMembership(const unsigned int &player,
                                        const arma::vec &   xOfI,
                                        bool                normalization = true);
           int  hybridBranching(const unsigned int player, OuterTree::Node *node);
           int  infeasibleBranching(const unsigned int player, const OuterTree::Node *node);
           int  deviationBranching(const unsigned int player, const OuterTree::Node *node);
           std::unique_ptr<GRBModel> getFeasQP(const unsigned int player, arma::vec x);
           void addValueCut(const unsigned int player, const double RHS, const arma::vec xMinusI);
           bool separationOracle(
                arma::vec &xOfI, arma::vec &x, unsigned int player, int budget, bool &addedCuts);
        };
     } // namespace EPEC
   
   } // namespace Algorithms
